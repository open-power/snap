----------------------------------------------------------------------------
----------------------------------------------------------------------------
--
-- Copyright 2016 International Business Machines
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions AND
-- limitations under the License.
--
----------------------------------------------------------------------------
----------------------------------------------------------------------------

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--
-- Note:
-- TAG LAYOUT:
-- 76543210
-- read tags
-- 000xxxxx x"00"-x"1F" => tags controled by read_ctrl_q,  4:0 RAM read address
-- 0100---0 x"40"       => first  read prefetch tag,  current page
-- 0100---1 x"41"       => second read prefetch tag,  current page
-- 0010---0 x"20"       => write after read, read_cl_lck
-- write tags
-- 100xxxxx x"80"-x"9F" => tags controled by write_ctrl_q, 4:0 RAM write address
-- 101xxxxx x"A0"-x"BF" => write after read, write unlock, 4:0 indicates the merging CL (RAM write address)
-- 1100---0 x"C0"       => first  write prefetch tags, current page
-- 1100---1 x"C1"       => second write prefetch tags, current page
-- ah_c tags
-- 11110000 x"F0"       => single command: restart
-- 11110001 x"F1"       => single command: interrupt
--
-- ToDos:
--  * request 32 read/write tags if possible, instead of 31
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_misc.all;
USE ieee.std_logic_unsigned.all;
USE ieee.numeric_std.all;

USE work.psl_accel_types.ALL;
USE work.snap_core_types.all;
USE work.dma_types.all;


ENTITY dma IS
  PORT (
    --
    -- pervasive
    ha_pclock              : IN  std_logic;
    afu_reset              : IN  std_logic;
    --
    -- PSL Interface
    ha_c_i                 : IN  HA_C_T;
    ha_r_i                 : IN  HA_R_T;
    ha_b_i                 : IN  HA_B_T;
    ah_c_o                 : OUT AH_C_T;
    ah_b_o                 : OUT AH_B_T;
    hd_s_i                 : IN  HD_S_T;
    hd_c_i                 : IN  HD_C_T;
    dh_d_o                 : OUT DH_D_T;
    --
    -- CTRL Manager Interface
    cd_c_i                 : IN  CD_C_T;
    --
    -- MMIO Interface
    mmd_a_i                : IN  MMD_A_T;
    mmd_c_i                : IN  MMD_C_T;
    mmd_i_i                : IN  MMD_I_T;
    dmm_c_o                : OUT DMM_C_T;
    dmm_e_o                : OUT DMM_E_T;
    --
    -- AXI SLAVE Interface
    sd_c_i                 : IN  SD_C_T;
    ds_c_o                 : OUT DS_C_T;
    sd_d_i                 : IN  SD_D_T;
    ds_d_o                 : OUT DS_D_T
  );
END dma;

ARCHITECTURE dma OF dma IS
  --
  -- CONSTANT
  CONSTANT INTSRC     : std_logic_vector(11 DOWNTO 0) := x"001";
  CONSTANT VALUE_64   : std_logic_vector(63 DOWNTO 6) := x"0000_0000_0000_00" & "01";
  CONSTANT VALUE_128  : std_logic_vector(63 DOWNTO 7) := x"0000_0000_0000_00" & '1';
  CONSTANT VALUE_128_P: std_logic                     := '0';
  CONSTANT VALUE_512  : std_logic_vector(63 DOWNTO 9) := x"0000_0000_0000_0" & "001";

  --
  -- TYPE
  TYPE GATE_INDICATION_T IS (OPENED, CLOSED);
  TYPE FSM_REQ_T         IS (NONE, RESTART, COMMAND);

  TYPE READ_CTRL_FSM_T IS (ST_FSM_ERROR, ST_RSP_ERROR, ST_IDLE,
                           ST_RESTART, ST_READ_RSP,
                           ST_WAIT_4_CTRL_UPDTAE, ST_WAIT_4_RSP_OR_BUF,
                           ST_COM_XLAT_RD_P0
                          );
  TYPE WRITE_CTRL_FSM_T IS (ST_FSM_ERROR, ST_RSP_ERROR, ST_IDLE,
                            ST_RESTART, ST_READ_RSP,
                            ST_WAIT_4_CTRL_UPDTAE, ST_WAIT_4_RSP_OR_BUF,
                            ST_COM_XLAT_WR_P0
                           );
  TYPE DMA_FSM_T IS (ST_FSM_ERROR, ST_IDLE,
                     ST_DMA_READ_REQ, ST_DMA_WRITE_REQ
                    );
  TYPE AH_C_FSM_T IS (ST_FSM_ERROR, ST_RSP_ERROR, ST_IDLE,
                      ST_COM_RESTART, ST_COM_INT_REQ, ST_WAIT_4_RSP,
                      ST_READ_FSM_ACTIVE, ST_WRITE_FSM_ACTIVE
                     );

  TYPE AH_RWC_T IS RECORD
    valid       : std_logic;                           -- Command valid
    tag         : std_logic_vector(7  DOWNTO 0);       -- Command tag
    tagpar      : std_logic;                           -- Command tag parity
    com         : CMD_CODES_T;                         -- Command code
    compar      : std_logic;                           -- Command code parity
    abt         : std_logic_vector(2 DOWNTO 0);        -- Command ABT
    ea          : std_logic_vector(63 DOWNTO 6);       -- Command address
    eapar       : std_logic;                           -- Command address parity
  END RECORD AH_RWC_T;

  --
  -- ATTRIBUTE
  ATTRIBUTE syn_encoding : string;
  ATTRIBUTE syn_encoding OF READ_CTRL_FSM_T  : TYPE IS "safe";
  ATTRIBUTE syn_encoding OF DMA_FSM_T        : TYPE IS "safe";
  ATTRIBUTE syn_encoding OF WRITE_CTRL_FSM_T : TYPE IS "safe";
  ATTRIBUTE syn_encoding OF AH_C_FSM_T       : TYPE IS "safe";

  --
  -- SIGNAL
  SIGNAL ah_c_counter_q              : integer RANGE 0 TO 255;
  SIGNAL ah_c_fsm_q                  : AH_C_FSM_T;
  SIGNAL dma_fsm_q                   : DMA_FSM_T;
  SIGNAL ah_c_max_q                  : std_logic_vector(7 DOWNTO 0);
  SIGNAL ah_c_max_reached_q          : boolean;
  SIGNAL ah_c_q                      : AH_C_T;
  SIGNAL dh_d_q                      : DH_D_T;
  SIGNAL ah_c_rgate_q                : GATE_INDICATION_T;
  SIGNAL ah_c_rsp_err_addr_p_q       : std_logic;
  SIGNAL ah_c_rsp_err_addr_q         : std_logic_vector(63 DOWNTO 0);
  SIGNAL ah_c_rsp_err_first_q        : boolean;
  SIGNAL ah_c_rsp_err_type_q         : RSP_CODES_T;
  SIGNAL ah_c_rsp_err_valid_q        : boolean;
  SIGNAL ah_c_wgate_q                : GATE_INDICATION_T;
  SIGNAL ah_rc_q                     : AH_RWC_T;
  SIGNAL ah_wc_q                     : AH_RWC_T;
  SIGNAL buf_rdata                   : std_logic_vector(511 DOWNTO  0);
  SIGNAL buf_rdata_e_q               : std_logic;
  SIGNAL buf_rdata_p                 : std_logic_vector(  7 DOWNTO  0);
  SIGNAL buf_rdata_vld               : std_logic;
  SIGNAL buf_rdata_end               : std_logic;
  SIGNAL buf_rrdreq                  : std_logic;
  SIGNAL buf_wrdreq_q                : boolean;
  SIGNAL buf_wram_wready             : std_logic;
  SIGNAL buf_rtag_p_q                : std_logic;
  SIGNAL buf_rtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL buf_rtag_valid_q            : boolean;
  SIGNAL buf_wwen_q                  : boolean;
  SIGNAL buf_wactive_q               : boolean;
  SIGNAL action_reset_req_q          : std_logic;
  SIGNAL sent_action_reset_req_q     : std_logic;
  SIGNAL action_reset_context_id_q   : std_logic_vector(CONTEXT_BITS-1 DOWNTO 0);
  SIGNAL quiesce_q                   : std_logic;
  SIGNAL buf_wtag_p_q                : std_logic;
  SIGNAL buf_wtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL buf_wtag_valid_q            : boolean;
  SIGNAL utc_rtag_next_q             : std_logic_vector(  5 DOWNTO  0);
  SIGNAL dma_req_wtag_q              : std_logic_vector(  5 DOWNTO  0);
  SIGNAL dma_rtag_next_q             : std_logic_vector(  5 DOWNTO  0);
  SIGNAL dma_rtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL dma_wtag_next_q             : std_logic_vector(  5 DOWNTO  0);
  SIGNAL dma_wtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL utc_rtag_p_q                : std_logic;
  SIGNAL utc_rtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL utc_wtag_next_q             : std_logic_vector(  5 DOWNTO  0);
  SIGNAL utc_wtag_p_q                : std_logic;
  SIGNAL utc_wtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL com_rtag_next_q             : std_logic_vector(  5 DOWNTO  0);
  SIGNAL com_rtag_p_q                : std_logic;
  SIGNAL com_rtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL com_rtag_qq                 : integer RANGE 0 TO 31;
  SIGNAL com_rtag_valid_q            : boolean;
  SIGNAL com_wtag_next_q             : std_logic_vector(  5 DOWNTO  0);
  SIGNAL com_wtag_p_q                : std_logic;
  SIGNAL com_wtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL com_wtag_qq                 : integer RANGE 0 TO 31;
  SIGNAL dma_rreq_cnt_q              : integer RANGE 0 TO 8;
  SIGNAL dma_wreq_cnt_q              : integer RANGE 0 TO 8;
  SIGNAL com_wtag_valid_q            : boolean;
  SIGNAL context_handle_q            : std_logic_vector(15 DOWNTO 0);
  SIGNAL dmm_e_q                     : DMM_E_T := (OTHERS => '0');
  SIGNAL ha_c_q                      : HA_C_T;
  SIGNAL ha_r_q                      : HA_R_T;
  SIGNAL hd_c_q                      : HD_C_T;
  SIGNAL hd_s_q                      : HD_S_T;
  SIGNAL hd_c_size_q                 : std_logic_vector(9 DOWNTO 0);
  SIGNAL intreq_active_q             : boolean;
  SIGNAL int_src_q                   : std_logic_vector(INT_BITS-1 DOWNTO 0);
  SIGNAL int_ctx_q                   : std_logic_vector(CONTEXT_BITS-1 DOWNTO 0);
  SIGNAL int_req_ack_q               : std_logic;
  SIGNAL mmd_a_q                     : MMD_A_T;
  SIGNAL mmd_i_q                     : MMD_I_T;
  SIGNAL raddr_id_q                  : std_logic_vector(C_S_AXI_ID_WIDTH-1 DOWNTO 0);
  SIGNAL raddr_q                     : std_logic_vector( 63 DOWNTO  6);
  SIGNAL rlen_q                      : std_logic_vector(  8 DOWNTO  0);
  SIGNAL read_ctrl_fsm_q             : READ_CTRL_FSM_T;
  SIGNAL read_ctrl_q                 : ARR_UTAG_CTL_T;
  SIGNAL read_ctrl_q_err_q           : std_logic_vector( 31 DOWNTO  0);
  SIGNAL read_ctrl_rsp_rtag_q        : UTAG_CTL_T;
  SIGNAL read_fsm_req_q              : FSM_REQ_T;
  SIGNAL read_rsp_err_addr_p_q       : std_logic;
  SIGNAL read_rsp_err_addr_q         : std_logic_vector(63 DOWNTO 0);
  SIGNAL read_rsp_err_first_q        : boolean;
  SIGNAL rd_req_ack_q                : boolean;
  SIGNAL wr_req_ack_q                : boolean;
  SIGNAL read_rsp_err_type_q         : RSP_CODES_T;
  SIGNAL read_rsp_err_valid_q        : boolean;
  SIGNAL restart_active_q            : boolean;
  SIGNAL rfifo_empty                 : std_logic;
  SIGNAL rfifo_full                  : std_logic;
  SIGNAL rfifo_prog_full             : std_logic;
  SIGNAL rfifo_rd_rst_busy           : std_logic;
  SIGNAL rfifo_rdata                 : std_logic_vector(512 DOWNTO 0);
  SIGNAL rfifo_wdata                 : std_logic_vector(512 DOWNTO 0);
  SIGNAL buf_wdata                   : std_logic_vector(1023 DOWNTO 0);
  SIGNAL buf_wdata_vld               : std_logic;
  SIGNAL buf_wdata_end               : std_logic;
  SIGNAL buf_wdata_type              : std_logic_vector(2 DOWNTO 0);
  SIGNAL rfifo_wr_rst_busy           : std_logic;
  SIGNAL rsp_rtag_next_q             : std_logic_vector(  5 DOWNTO  0);
  SIGNAL rsp_rtag_p_q                : std_logic;
  SIGNAL rsp_rtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL rsp_rtag_qq                 : integer RANGE 0 TO 31;
  SIGNAL rsp_rtag_valid_q            : boolean;
  SIGNAL rsp_wtag_next_q             : std_logic_vector(  5 DOWNTO  0);
  SIGNAL rsp_wtag_p_q                : std_logic;
  SIGNAL rsp_wtag_q                  : std_logic_vector(  5 DOWNTO  0);
  SIGNAL rsp_wtag_qq                 : integer RANGE 0 TO 31;
  SIGNAL rsp_wtag_valid_q            : boolean;
  SIGNAL sd_c_q                      : SD_C_T;
  SIGNAL rd_ctx_q                    : std_logic_vector(CONTEXT_BITS-1 DOWNTO 0);
  SIGNAL wr_ctx_q                    : std_logic_vector(CONTEXT_BITS-1 DOWNTO 0);
  SIGNAL waddr_id_q                  : std_logic_vector(C_S_AXI_ID_WIDTH-1 DOWNTO 0);
  SIGNAL waddr_q                     : std_logic_vector( 63 DOWNTO  6);
  SIGNAL wlen_q                      : std_logic_vector(  8 DOWNTO  0);
  SIGNAL wr_id_valid_q               : std_logic;
  SIGNAL write_ctrl_fsm_q            : WRITE_CTRL_FSM_T;
  SIGNAL write_ctrl_q                : ARR_UTAG_CTL_T;
  SIGNAL write_ctrl_q_err_q          : std_logic_vector( 31 DOWNTO  0);
  SIGNAL write_ctrl_rsp_wtag_q       : UTAG_CTL_T;
  SIGNAL write_fsm_req_q             : FSM_REQ_T;
  SIGNAL write_rsp_err_addr_p_q      : std_logic;
  SIGNAL write_rsp_err_addr_q        : std_logic_vector(63 DOWNTO 0);
  SIGNAL write_rsp_err_first_q       : boolean;
  SIGNAL write_rsp_err_type_q        : RSP_CODES_T;
  SIGNAL write_rsp_err_valid_q       : boolean;

  --
  -- COMPONENT
  COMPONENT fifo_513x512
    PORT (
      clk : IN STD_LOGIC;
      srst : IN STD_LOGIC;
      din : IN STD_LOGIC_VECTOR(512 DOWNTO 0);
      wr_en : IN STD_LOGIC;
      rd_en : IN STD_LOGIC;
      dout : OUT STD_LOGIC_VECTOR(512 DOWNTO 0);
      full : OUT STD_LOGIC;
      empty : OUT STD_LOGIC;
      prog_full : OUT STD_LOGIC;
      wr_rst_busy : OUT STD_LOGIC;
      rd_rst_busy : OUT STD_LOGIC
    );
  END COMPONENT;

BEGIN
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- ******************************************************
-- ***** DMA READ LOGIC                             *****
-- ******************************************************
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- Read Control FSM
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    --
    read_ctrl_fsm : PROCESS (ha_pclock)
      VARIABLE com_active_v     : boolean;
      VARIABLE utc_in_use_v     : boolean;
      VARIABLE com_rtag_v       : integer RANGE 0 TO 31;
      VARIABLE com_rtag_next_v  : integer RANGE 0 TO 31;
      VARIABLE rsp_rtag_v       : integer RANGE 0 TO 31;
      VARIABLE rsp_rtag_next_v  : integer RANGE 0 TO 31;
    BEGIN
      IF (rising_edge(ha_pclock)) THEN
        --
        -- defaults
        --
        com_rtag_v            := to_integer(unsigned(com_rtag_q     (4 DOWNTO 0)));
        com_rtag_next_v       := to_integer(unsigned(com_rtag_next_q(4 DOWNTO 0)));
        rsp_rtag_v            := to_integer(unsigned(rsp_rtag_q     (4 DOWNTO 0)));
        rsp_rtag_next_v       := to_integer(unsigned(rsp_rtag_next_q(4 DOWNTO 0)));

        ah_rc_q               <= ( '0',             -- valid
                                  (OTHERS => '0'),  -- tag
                                   '1',             -- tag parity
                                   INVALID,        -- command
                                   '1',             -- command parity
                                  (OTHERS => '0'),  -- abt
                                  (OTHERS => '0'),  -- address
                                   '1');            -- address parity
        com_rtag_q            <= com_rtag_q;
        com_rtag_next_q       <= com_rtag_next_q;
        com_rtag_p_q          <= com_rtag_p_q;
        com_rtag_valid_q      <= FALSE;
        context_handle_q      <= context_handle_q;
        read_rsp_err_valid_q  <= read_rsp_err_valid_q;
        read_rsp_err_first_q  <= read_rsp_err_first_q;
        read_rsp_err_type_q   <= read_rsp_err_type_q;
        read_rsp_err_addr_q   <= read_rsp_err_addr_q;
        read_rsp_err_addr_p_q <= read_rsp_err_addr_p_q;
        read_ctrl_fsm_q       <= read_ctrl_fsm_q;
        read_ctrl_rsp_rtag_q  <= read_ctrl_q(rsp_rtag_v);
        read_fsm_req_q        <= read_fsm_req_q;
        rsp_rtag_q            <= rsp_rtag_q;
        rsp_rtag_next_q       <= rsp_rtag_next_q;
        rsp_rtag_p_q          <= rsp_rtag_p_q;
        rsp_rtag_valid_q      <= FALSE;

        dmm_e_q.read_ctrl_fsm_err <= '0';

        --
        -- F S M
        --
        CASE read_ctrl_fsm_q IS
          --
          -- STATE IDLE
          --
          WHEN ST_IDLE =>
            --
            -- FSM starts if one CL in use
            --
            --
            -- check all UTAGs
            utc_in_use_v := FALSE;

            FOR i IN 0 TO 31 LOOP
              IF read_ctrl_q(i).utt /= UTC_NOT_USED THEN
                utc_in_use_v := TRUE;
              END IF;
            END LOOP;  -- i

            IF utc_in_use_v = TRUE THEN
              read_ctrl_fsm_q <= ST_WAIT_4_RSP_OR_BUF;
            END IF;

          --
          -- STATE RESTART
          --
          WHEN ST_RESTART =>
            com_rtag_q       <= rsp_rtag_q;
            com_rtag_next_q  <= rsp_rtag_next_q;
            com_rtag_p_q     <= rsp_rtag_p_q;

            --
            -- check all commands done
            com_active_v    := FALSE;

            FOR i IN 0 TO 31 LOOP
              IF read_ctrl_q(i).com = ACTIVE THEN
                com_active_v := TRUE;
              END IF;
            END LOOP;  -- i

            IF (com_active_v = FALSE) THEN
              IF (read_fsm_req_q = COMMAND) THEN
                IF (ah_c_rgate_q = OPENED) THEN
                  read_ctrl_fsm_q <= ST_COM_XLAT_RD_P0;
                END IF;
              ELSE
                read_fsm_req_q  <= RESTART;

                IF restart_active_q = TRUE THEN
                  read_fsm_req_q <= COMMAND;
                END IF;
              END IF;
            END IF;

          --
          -- STATE READ RESPONSE
          --
          WHEN ST_READ_RSP =>
            --
            -- stay in this state if the next response is valid
            --
            IF read_ctrl_q(rsp_rtag_next_v).rsp /= ILLEGAL_RSP  THEN
              read_ctrl_fsm_q <= ST_READ_RSP;
            ELSE
              read_ctrl_fsm_q <= ST_WAIT_4_RSP_OR_BUF;
            END IF;

            --
            -- load to the next read_ctrl_q slice
            --
            read_ctrl_rsp_rtag_q <= read_ctrl_q(rsp_rtag_next_v);

            --
            -- process current response
            --
            IF read_ctrl_rsp_rtag_q.rsp = DONE THEN
              rsp_rtag_valid_q    <= TRUE;
              rsp_rtag_q          <= rsp_rtag_q      + 1;
              rsp_rtag_next_q     <= rsp_rtag_next_q + 1;
              rsp_rtag_p_q        <= AC_PPARITH(1, rsp_rtag_q, rsp_rtag_p_q,
                                                     "000001"  , '0');

            ELSIF (read_ctrl_rsp_rtag_q.rsp = AERROR ) OR
                  (read_ctrl_rsp_rtag_q.rsp = DERROR ) OR
                  (read_ctrl_rsp_rtag_q.rsp = FAILED ) OR
                  (read_ctrl_rsp_rtag_q.rsp = CONTEXT) THEN
              read_ctrl_fsm_q      <= ST_RSP_ERROR;

            ELSE
              read_ctrl_fsm_q <= ST_RESTART;
            END IF;

          --------------------------------------------------------------------
          -- WAIT STATES
          --------------------------------------------------------------------
          --
          -- STATE WAIT: FOR ctrl register update
          --
          WHEN ST_WAIT_4_CTRL_UPDTAE =>
              read_ctrl_fsm_q <= ST_WAIT_4_RSP_OR_BUF;

          --
          --
          -- STATE WAIT: FOR RESPONSE OR BUFFER
          --
          WHEN ST_WAIT_4_RSP_OR_BUF =>
            --
            -- default
            read_fsm_req_q <= NONE;

            --
            -- new response available
            IF (read_ctrl_q(rsp_rtag_v).rsp /= ILLEGAL_RSP) THEN
              read_ctrl_fsm_q <= ST_READ_RSP;

            -- new buffer available
            ELSIF (com_rtag_q /= utc_rtag_q) THEN
              read_fsm_req_q <= COMMAND;

              IF (ah_c_rgate_q   = OPENED ) AND
                 (read_fsm_req_q = COMMAND) THEN
                read_ctrl_fsm_q <= ST_COM_XLAT_RD_P0;
              END IF;

            -- WRITE FSM or AH_C_FSM detects a response error
            ELSIF (write_rsp_err_valid_q = TRUE) OR
                  (ah_c_rsp_err_valid_q  = TRUE) THEN
              read_ctrl_fsm_q <= ST_RSP_ERROR;
            END IF;

            --
            -- check all CL transferred
            utc_in_use_v := FALSE;

            FOR i IN 0 TO 31 LOOP
              IF read_ctrl_q(i).utt /= UTC_NOT_USED THEN
                utc_in_use_v := TRUE;
              END IF;
            END LOOP;  -- i

            IF utc_in_use_v = FALSE THEN
              read_fsm_req_q <= NONE;
              read_ctrl_fsm_q <= ST_IDLE;
            END IF;

          --------------------------------------------------------------------
          -- COMMAND STATES
          --------------------------------------------------------------------
          --
          -- STATE COMMAND: XLAT_RD_P0
          --
          WHEN ST_COM_XLAT_RD_P0 =>
            IF (ah_c_rgate_q     = OPENED    ) AND
               (com_rtag_next_q /= utc_rtag_q) THEN
              read_ctrl_fsm_q <= ST_COM_XLAT_RD_P0;
            ELSE
              read_ctrl_fsm_q <= ST_WAIT_4_CTRL_UPDTAE;
              read_fsm_req_q  <= NONE;
            END IF;

            com_rtag_valid_q   <= TRUE;
            com_rtag_q         <= com_rtag_q      + 1;
            com_rtag_next_q    <= com_rtag_next_q + 1;
            com_rtag_p_q       <= AC_PPARITH(1, com_rtag_q, com_rtag_p_q,
                                                "000001"  , '0');
            ah_rc_q.valid      <= '1';
            ah_rc_q.tag        <= "000" & com_rtag_q(4 DOWNTO 0);
            ah_rc_q.tagpar     <= com_rtag_q(5) XOR com_rtag_p_q;
            ah_rc_q.com        <= XLAT_RD_P0;
            ah_rc_q.compar     <= parity_gen_odd(ENCODE_CMD_CODES(XLAT_RD_P0));
            ah_rc_q.abt        <= "010";

            ah_rc_q.ea          <= read_ctrl_q(com_rtag_v).uta(63 DOWNTO 6);
            ah_rc_q.eapar       <= parity_gen_odd(read_ctrl_q(com_rtag_v).uta(63 DOWNTO 6));

          --------------------------------------------------------------------
          -- ERROR STATES
          --------------------------------------------------------------------
          --
          -- STATE RESPONSE ERROR
          --
          WHEN ST_RSP_ERROR =>
            --
            -- collect all information
            read_rsp_err_type_q  <= read_ctrl_rsp_rtag_q.rsp;
            read_rsp_err_addr_q   <= (OTHERS => '0'); -- raddr_q(63 DOWNTO 7) & "0000000";
            read_rsp_err_addr_p_q <= '0';             -- raddr_p_q;

            --
            -- how is first check
            IF (write_ctrl_fsm_q /= ST_RSP_ERROR) OR
               (ah_c_fsm_q       /= ST_RSP_ERROR) THEN
              read_rsp_err_first_q <= TRUE;
            END IF;

            --
            -- check all commands done
            com_active_v    := FALSE;

            FOR i IN 0 TO 31 LOOP
              IF read_ctrl_q(i).com = ACTIVE THEN
                com_active_v := TRUE;
              END IF;
            END LOOP;  -- i

            IF com_active_v = FALSE THEN
              read_rsp_err_valid_q <= TRUE;
            END IF;


          --
          -- STATE FSM ERROR
          --
          WHEN ST_FSM_ERROR =>
            dmm_e_q.read_ctrl_fsm_err <= '1';

        END CASE;

        --------------------------------------------------------------------
        -- Reset Logic
        --------------------------------------------------------------------
        --
        --
        --
        IF afu_reset = '1' THEN
          --
          -- initial values
          --
          com_rtag_q            <= (OTHERS => '0');
          com_rtag_next_q       <= "000001";
          com_rtag_p_q          <= '1';
          context_handle_q      <= (OTHERS => '0');
          read_rsp_err_first_q  <= FALSE;
          read_rsp_err_valid_q  <= FALSE;
          read_rsp_err_type_q   <= ILLEGAL_RSP;
          read_ctrl_fsm_q       <= ST_IDLE;
          read_fsm_req_q        <= NONE;
          rsp_rtag_q            <= (OTHERS => '0');
          rsp_rtag_next_q       <= "000001";
          rsp_rtag_p_q          <= '1';
        END IF;
      END IF;
    END PROCESS read_ctrl_fsm;


  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- READ CONTROL REGISTER
  --
  -- Content: 32x(com   1    -- command valid bit
  --              rsp   4    -- response codes
  --              dma   2    -- psl dma control
  --              buf   2    -- dma buffer status
  --              utt   3    -- utag type
  --              uta   58   -- utag address
  --
  -- Indication:
  --                               |    COM   |     RSP     |  BUF  | DMA       |  UTT
  --  ========================================================================================
  --  1)tag is free and the        | INACTIVE | ILLEGAL_RSP | EMPTY | EMPTY     |  UTC_NOT_USED
  --    buffer is empty            |          |             |       |           |
  --                               |          |             |       |           |
  --  2)reserve buffer space       | INACTIVE | ILLEGAL_RSP | EMPTY | EMPTY     |  COMPLETE
  --                               |          |             |       |           |
  --  3)request a xlat for this CL | ACTIVE   | ILLEGAL_RSP | EMPTY | EMPTY     |  COMPLETE
  --                               |          |             |       |           |
  --  4)received xlat response     | INACTIVE | HA_RSP_CODE | EMPTY | EMPTY     |  COMPLETE
  --    from HA                    |          |             |       |           |
  --                               |          |             |       |           |
  --  5)response DONE and the ITAG | INACTIVE | ILLEGAL_RSP | EMPTY | XLAT_DONE |  COMPLETE
  --    is available, request data |          |             |       |           |
  --                               |          |             |       |           |
  --  6)PSL have accept the DMA    | INACTIVE | ILLEGAL_RSP | EMPTY | REQ_DONE  |  COMPLETE
  --    request                    |          |             |       |           |
  --                               |          |             |       |           |
  --  7)DMA request DONE and DATA  | INACTIVE | ILLEGAL_RSP | FULL  | EMPTY     |  COMPLETE
  --    available, ready to read   |          |             |       |           |
  --
  --
  -- Flow Control:
  --    steps                  | read_ctrl_q          |  H<->A Interface
  --  ==========================================================================
  --    1) rlen > 1 CL AND     | utt=COMPLETE         |
  --       utt  = UTC_NOT_USE  |                      |
  --                           |                      |
  --    2)                     | com=ACTIVE           |  READ XLAT COMMAND VALID
  --                           | rsp=ILLEGAL_RSP      |
  --                           |                      |
  --    3) response from PSL   | rsp=ha_r_q.response  |  RSP VALID
  --                           | com=INACTIVE         |
  --                           |                      |
  --    4) rsp = DONE          | dma=XLAT_DONE        | sent DMA read request
  --                           | rsp=ILLEGAL_RSP      | to the PSL
  --                           |                      |
  --    5) hd_s.valid = '1'    | dma=EMPTY            | PSL accept the request
  --                           |                      |
  --    6) hd_c.valid = '1'    | buf=FULL             | DATA are available
  --                           |                      |
  --    7) 1 CL reads out of   | buf=EMPTY            |
  --       the dma_buffer      |                      |
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    --
    read_ctrl_reg : PROCESS (ha_pclock)
      VARIABLE buf_rtag_v      : integer RANGE 0 TO 31;
      VARIABLE utc_rtag_v      : integer RANGE 0 TO 31;
      VARIABLE utc_rtag_next_v : integer RANGE 0 TO 31;
      VARIABLE cl_calc_v       : std_logic_vector(5 DOWNTO 0);
      VARIABLE ha_r_tag_v      : integer RANGE 0 TO 31;
      VARIABLE hd_c_utag_v     : integer RANGE 0 TO 31;
      VARIABLE hd_s_utag_v     : integer RANGE 0 TO 31;
      VARIABLE hd_c_size_v     : std_logic_vector(9 DOWNTO 0);
    BEGIN
      IF (rising_edge(ha_pclock)) THEN
        --
        -- defaults
        --
        buf_rdata_e_q      <= '0';
        utc_rtag_q         <= utc_rtag_q;
        utc_rtag_next_q    <= utc_rtag_next_q;
        utc_rtag_p_q       <= utc_rtag_p_q;
        com_rtag_qq        <= to_integer(unsigned(com_rtag_q(4 DOWNTO 0)));
        rsp_rtag_qq        <= to_integer(unsigned(rsp_rtag_q(4 DOWNTO 0)));

        raddr_q            <= raddr_q;
        raddr_id_q         <= raddr_id_q;
        rlen_q             <= rlen_q;
        read_ctrl_q        <= read_ctrl_q;
        rd_req_ack_q       <= FALSE;
        rd_ctx_q           <= rd_ctx_q;

        buf_rtag_v         := to_integer(unsigned(buf_rtag_q     (4 DOWNTO 0)));
        utc_rtag_v         := to_integer(unsigned(utc_rtag_q     (4 DOWNTO 0)));
        utc_rtag_next_v    := to_integer(unsigned(utc_rtag_next_q(4 DOWNTO 0)));
        ha_r_tag_v         := to_integer(unsigned(ha_r_q.tag     (4 DOWNTO 0)));
        hd_s_utag_v        := to_integer(unsigned(hd_s_q.utag    (4 DOWNTO 0)));
        hd_c_utag_v        := to_integer(unsigned(hd_c_q.utag    (4 DOWNTO 0)));

        --
        -- UTT: CACHE LINE TYPE TAG IS VALID and
        -- UTS: CACHE LINE SIZE
        --
        -- Note: The alignment on the CAPI 2.0 DMA Data interface is
        --       first byte first.
        IF (read_ctrl_q(utc_rtag_v).utt  = UTC_NOT_USED) AND
           (rlen_q                      /= 0           ) THEN
          --
          -- update the utt in the read control register
          --
          IF raddr_q(8 DOWNTO 6) /= "000" THEN
            IF (or_reduce(rlen_q(8 DOWNTO 4))                              = '1'     ) OR 
               ((('0' & rlen_q(3 DOWNTO 0)) + ("00" & raddr_q(8 DOWNTO 6))) > "01000") THEN
              rlen_q                      <= rlen_q - ("1000" - ('0' & raddr_q(8 DOWNTO 6)));
              read_ctrl_q(utc_rtag_v).uts <=  ("1000" - ('0' & raddr_q(8 DOWNTO 6)));
              read_ctrl_q(utc_rtag_v).utt <= UTC_FIRST;
            ELSE
              rlen_q                      <= (OTHERS => '0');
              read_ctrl_q(utc_rtag_v).uts <=  '0' & rlen_q(2 DOWNTO 0);
              read_ctrl_q(utc_rtag_v).utt <= UTC_LAST;
            END IF;
          ELSE
            IF rlen_q > 8 THEN
              read_ctrl_q(utc_rtag_v).uts <= "1000";
              read_ctrl_q(utc_rtag_v).utt <= UTC_COMPLETE;
              rlen_q <= rlen_q - 8;
            ELSIF rlen_q = 8 THEN
              read_ctrl_q(utc_rtag_v).uts <= "1000";
              read_ctrl_q(utc_rtag_v).utt <= UTC_LAST;
              rlen_q <= rlen_q - 8;
            ELSE
              read_ctrl_q(utc_rtag_v).uts <=  '0' & rlen_q(2 DOWNTO 0);
              read_ctrl_q(utc_rtag_v).utt <= UTC_LAST;
              rlen_q <= (OTHERS => '0');
            END IF;
          END IF;

          --
          -- CL Read Address
          read_ctrl_q(utc_rtag_v).uta   <= raddr_q(63 DOWNTO 6);

          --
          -- calculate the next read address
          raddr_q(63 DOWNTO 9) <= raddr_q(63 DOWNTO 9)  + VALUE_512;
          raddr_q( 8 DOWNTO 6) <= (OTHERS => '0');

          --
          -- calculate the next utc rtag
          utc_rtag_q      <= utc_rtag_q      + 1;
          utc_rtag_next_q <= utc_rtag_next_q + 1;
          utc_rtag_p_q    <= AC_PPARITH(1, utc_rtag_q, utc_rtag_p_q,
                                           "000001"  , '0');
        END IF;

        --
        -- request
        IF (sd_c_q.rd_req = '1') AND
           (quiesce_q     = '0') AND
           (rlen_q        = 0  ) THEN
          --
          -- save the read address, id and length for later use
          raddr_q    <=  sd_c_q.rd_addr(63 DOWNTO 6);
          raddr_id_q <=  sd_c_q.rd_id;
          rd_ctx_q   <=  sd_c_q.rd_ctx;
          rlen_q     <= ('0' & sd_c_q.rd_len) + 1;

          --
          -- send back a AXI read acknowledge
          rd_req_ack_q <= TRUE;
        END IF;

        --
        -- COM: COMMAND TAG IS VALID
        --
        IF com_rtag_valid_q = TRUE THEN
          read_ctrl_q(com_rtag_qq).com <= ACTIVE;
          read_ctrl_q(com_rtag_qq).rsp <= ILLEGAL_RSP;
        END IF;

        --
        -- RSP: VALID RESPONSE ON THE H->A INTERFACE
        --
        IF (ha_r_q.valid           = '1'  ) AND
           (ha_r_q.tag(7 DOWNTO 5) = "000") THEN
          read_ctrl_q(ha_r_tag_v).com  <= INACTIVE;
          read_ctrl_q(ha_r_tag_v).rsp  <= ha_r_q.response;
          read_ctrl_q(ha_r_tag_v).itag <= ha_r_q.ditag;
        END IF;

        --
        -- RSP: READ_CTRL_FSM_Q HAS READ THE RESPONSE
        --
        IF rsp_rtag_valid_q = TRUE THEN
          read_ctrl_q(rsp_rtag_qq).dma <= XLAT_DONE;
          read_ctrl_q(rsp_rtag_qq).rsp <= ILLEGAL_RSP;
        END IF;

        --
        -- DMA: DMA TAG ACCEPT the REQUEST
        --
        IF (hd_s_q.utag_valid       = '1'    ) AND
           (hd_s_q.utag(9 DOWNTO 5) = "00000") THEN
          read_ctrl_q(hd_s_utag_v).dma <= EMPTY;
        END IF;

        --
        -- BUF: Buffer is valid
        --
        -- Note: It is no longer necessary too compare the utag to identify
        --       read completions, because only read completions have
        --       ctype 0 or 1 
        IF (hd_c_q.valid = '1') THEN 
          hd_c_size_q <= hd_c_q.size - ("0" & x"80");

          IF (hd_c_q.ctype = "000")  THEN
             IF (hd_c_q.size >= ("00" & x"80")) THEN 
               hd_c_size_v := ("00" & x"80");
             ELSE
               hd_c_size_v := hd_c_q.size;
             END IF;
          
          ELSIF (hd_c_q.ctype = "001") THEN
            hd_c_size_v := hd_c_size_q;
          END IF;

          read_ctrl_q(hd_c_utag_v).buf <= read_ctrl_q(hd_c_utag_v).buf + ("00" & hd_c_size_v(7 DOWNTO 6));
        END IF;

        --
        -- BUF: BUFFER TAG is valid
        --
        IF buf_rtag_valid_q = TRUE THEN
          read_ctrl_q(buf_rtag_v).buf <= (OTHERS => '0');
          read_ctrl_q(buf_rtag_v).utt <= UTC_NOT_USED;
        END IF;

        --------------------------------------------------------------------
        -- Reset Logic
        --------------------------------------------------------------------
        --
        --
        --
        IF afu_reset = '1' THEN
          --
          -- initial values
          --
          FOR i IN 0 TO 31 LOOP
            read_ctrl_q(i).utt <= UTC_NOT_USED;
            read_ctrl_q(i).uts <= (OTHERS => '0');
            read_ctrl_q(i).rsp <= ILLEGAL_RSP;
            read_ctrl_q(i).com <= INACTIVE;
            read_ctrl_q(i).buf <= (OTHERS => '0');
            read_ctrl_q(i).dma <= EMPTY;
          END LOOP;  -- i

          utc_rtag_q         <= (OTHERS => '0');
          utc_rtag_next_q    <= "000001";
          utc_rtag_p_q       <= '1';
          com_rtag_qq        <= 0;
          rsp_rtag_qq        <= 0;

          rlen_q             <= (OTHERS => '0');
        END IF;
      END IF;
    END PROCESS read_ctrl_reg;



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- ******************************************************
-- ***** DMA WRITE LOGIC                            *****
-- ******************************************************
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- Write Control FSM
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    --
    write_ctrl_fsm : PROCESS (ha_pclock)
      VARIABLE utc_in_use_v     : boolean;
      VARIABLE com_active_v     : boolean;
      VARIABLE com_wtag_v       : integer RANGE 0 TO 31;
      VARIABLE com_wtag_next_v  : integer RANGE 0 TO 31;
      VARIABLE rsp_wtag_v       : integer RANGE 0 TO 31;
      VARIABLE rsp_wtag_next_v  : integer RANGE 0 TO 31;
    BEGIN
      IF (rising_edge(ha_pclock)) THEN
        --
        -- defaults
        --
        com_wtag_v            := to_integer(unsigned(com_wtag_q     (4 DOWNTO 0)));
        com_wtag_next_v       := to_integer(unsigned(com_wtag_next_q(4 DOWNTO 0)));
        rsp_wtag_v            := to_integer(unsigned(rsp_wtag_q     (4 DOWNTO 0)));
        rsp_wtag_next_v       := to_integer(unsigned(rsp_wtag_next_q(4 DOWNTO 0)));

        ah_wc_q                <= ( '0',             -- valid
                                   (OTHERS => '0'),  -- tag
                                    '1',             -- tag parity
                                    INVALID,        -- command
                                    '1',             -- command parity
                                   (OTHERS => '0'),  -- abt
                                   (OTHERS => '0'),  -- address
                                    '1');            -- address parity
        com_wtag_valid_q       <= FALSE;
        rsp_wtag_valid_q       <= FALSE;
        write_ctrl_fsm_q       <= write_ctrl_fsm_q;
        write_ctrl_rsp_wtag_q  <= write_ctrl_q(rsp_wtag_v);
        write_fsm_req_q        <= write_fsm_req_q;
        write_rsp_err_addr_p_q <= write_rsp_err_addr_p_q;
        write_rsp_err_addr_q   <= write_rsp_err_addr_q;
        write_rsp_err_first_q  <= write_rsp_err_first_q;
        write_rsp_err_type_q   <= write_rsp_err_type_q;
        write_rsp_err_valid_q  <= write_rsp_err_valid_q;

        dmm_e_q.write_ctrl_fsm_err <= '0';

        com_wtag_q             <= com_wtag_q;
        com_wtag_next_q        <= com_wtag_next_q;
        com_wtag_p_q           <= com_wtag_p_q;
        rsp_wtag_q             <= rsp_wtag_q;
        rsp_wtag_next_q        <= rsp_wtag_next_q;
        rsp_wtag_p_q           <= rsp_wtag_p_q;

        --
        -- F S M
        --
        CASE write_ctrl_fsm_q IS
          --
          -- STATE IDLE
          --
          WHEN ST_IDLE =>
            --
            -- FSM starts if one CL in use
            --
            --
            -- check all CLs
            utc_in_use_v := FALSE;

            FOR i IN 0 TO 31 LOOP
              IF write_ctrl_q(i).utt /= UTC_NOT_USED THEN
                utc_in_use_v := TRUE;
              END IF;
            END LOOP;  -- i

            IF utc_in_use_v = TRUE THEN
              write_ctrl_fsm_q <= ST_WAIT_4_RSP_OR_BUF;
            END IF;

          --
          -- STATE RESTART
          --
          WHEN ST_RESTART =>
            com_wtag_q       <= rsp_wtag_q;
            com_wtag_next_q  <= rsp_wtag_next_q;
            com_wtag_p_q     <= rsp_wtag_p_q;

            --
            -- check all commands done
            com_active_v    := FALSE;

            FOR i IN 0 TO 31 LOOP
              IF write_ctrl_q(i).com = ACTIVE THEN
                com_active_v := TRUE;
              END IF;
            END LOOP;  -- i

            IF com_active_v = FALSE THEN
              IF (write_fsm_req_q = COMMAND) THEN
                IF (ah_c_wgate_q = OPENED) THEN
                  write_ctrl_fsm_q <= ST_COM_XLAT_WR_P0;
                END IF;
              ELSE
                write_fsm_req_q  <= RESTART;

                IF restart_active_q = TRUE THEN
                  write_fsm_req_q <= COMMAND;
                END IF;
              END IF;
            END IF;


          --
          -- STATE READ RESPONSE
          --
          WHEN ST_READ_RSP =>
            --
            -- stay in this state if the next response is valid
            --
            IF write_ctrl_q(rsp_wtag_next_v).rsp /= ILLEGAL_RSP  THEN
              write_ctrl_fsm_q <= ST_READ_RSP;
            ELSE
              write_ctrl_fsm_q <= ST_WAIT_4_RSP_OR_BUF;
            END IF;

            --
            -- load to the next write_ctrl_q slice
            --
            write_ctrl_rsp_wtag_q <= write_ctrl_q(rsp_wtag_next_v);

            --
            -- process current response
            --
            IF write_ctrl_rsp_wtag_q.rsp = DONE THEN
              rsp_wtag_valid_q <= TRUE;
              rsp_wtag_q       <= rsp_wtag_q      + 1;
              rsp_wtag_next_q  <= rsp_wtag_next_q + 1;
              rsp_wtag_p_q     <= AC_PPARITH(1, rsp_wtag_q, rsp_wtag_p_q,
                                                "000001"  , '0');
            ELSIF (write_ctrl_rsp_wtag_q.rsp = AERROR) OR
                  (write_ctrl_rsp_wtag_q.rsp = DERROR ) OR
                  (write_ctrl_rsp_wtag_q.rsp = FAILED ) OR
                  (write_ctrl_rsp_wtag_q.rsp = CONTEXT) THEN
              write_ctrl_fsm_q   <= ST_RSP_ERROR;

            ELSE
              write_ctrl_fsm_q <= ST_RESTART;
            END IF;

          --------------------------------------------------------------------
          -- WAIT STATES
          --------------------------------------------------------------------
          --
          -- STATE WAIT: FOR ctrl register update
          --
          WHEN ST_WAIT_4_CTRL_UPDTAE =>
              write_ctrl_fsm_q <= ST_WAIT_4_RSP_OR_BUF;

          --
          -- STATE WAIT: FOR RESPONSE OR BUFFER
          --
          WHEN ST_WAIT_4_RSP_OR_BUF =>
            --
            -- default
            write_fsm_req_q <= NONE;

            --
            -- new response available
            IF (write_ctrl_q(rsp_wtag_v).rsp /= ILLEGAL_RSP) THEN
              write_ctrl_fsm_q      <= ST_READ_RSP;

            --
            -- new buffer available
            --
            ELSIF (write_ctrl_q(com_wtag_v).buf = write_ctrl_q(com_wtag_v).uts) AND
                  (com_wtag_q                  /= buf_wtag_q) THEN

              write_fsm_req_q  <= COMMAND;

              --
              -- trigger a full CL XLAT
              IF (ah_c_wgate_q    = OPENED ) AND
                 (write_fsm_req_q = COMMAND) THEN
                write_ctrl_fsm_q <= ST_COM_XLAT_WR_P0;
              END IF;

            -- READ FSM AH_C_FSM detects a response error
            ELSIF (read_rsp_err_valid_q = TRUE) OR
                  (ah_c_rsp_err_valid_q = TRUE) THEN
              write_ctrl_fsm_q <= ST_RSP_ERROR;
            END IF;

            --
            -- all CL transferred
            utc_in_use_v := FALSE;

            FOR i IN 0 TO 31 LOOP
              IF write_ctrl_q(i).utt /= UTC_NOT_USED THEN
                utc_in_use_v := TRUE;
              END IF;
            END LOOP;  -- i

            IF utc_in_use_v = FALSE THEN
              write_fsm_req_q   <= NONE;
              write_ctrl_fsm_q  <= ST_IDLE;
            END IF;

          --------------------------------------------------------------------
          -- COMMAND STATES
          --------------------------------------------------------------------
          --
          -- STATE COMMAND: XLAT_WR_P0
          --
          WHEN ST_COM_XLAT_WR_P0 =>
            IF (ah_c_wgate_q     = OPENED    ) AND
               (com_wtag_next_q /= buf_wtag_q) THEN
              write_ctrl_fsm_q <= ST_COM_XLAT_WR_P0;
            ELSE
              write_ctrl_fsm_q <= ST_WAIT_4_CTRL_UPDTAE;
              write_fsm_req_q  <= NONE;
            END IF;

            com_wtag_valid_q  <= TRUE;
            com_wtag_q        <= com_wtag_q      + 1;
            com_wtag_next_q   <= com_wtag_next_q + 1;
            com_wtag_p_q      <= AC_PPARITH(1, com_wtag_q, com_wtag_p_q,
                                               "000001"  , '0');

            ah_wc_q.valid     <= '1';
            ah_wc_q.tag       <= "100" & com_wtag_q(4 DOWNTO 0);
            ah_wc_q.tagpar    <= NOT (com_wtag_q(5) XOR com_wtag_p_q);
            ah_wc_q.com       <= XLAT_WR_P0;
            ah_wc_q.compar    <= parity_gen_odd(ENCODE_CMD_CODES(XLAT_WR_P0));
            ah_wc_q.abt       <= "010";

            ah_wc_q.ea        <= write_ctrl_q(com_wtag_v).uta;
            ah_wc_q.eapar     <= parity_gen_odd(write_ctrl_q(com_wtag_v).uta(63 DOWNTO 6));

          --------------------------------------------------------------------
          -- ERROR STATES
          --------------------------------------------------------------------
          --
          -- STATE RESPONSE ERROR
          --
          WHEN ST_RSP_ERROR =>
            --
            -- collect all information
            write_rsp_err_type_q   <= write_ctrl_rsp_wtag_q.rsp;
            write_rsp_err_addr_q   <= (OTHERS => '0'); -- waddr_q & "0000000";
            write_rsp_err_addr_p_q <= '0';             -- waddr_p_q;

            --
            -- how is first check
            IF (read_ctrl_fsm_q /= ST_RSP_ERROR) OR
               (ah_c_fsm_q      /= ST_RSP_ERROR) THEN
              write_rsp_err_first_q <= TRUE;
            END IF;

            --
            -- check all commands done
            com_active_v    := FALSE;

            FOR i IN 0 TO 31 LOOP
              IF write_ctrl_q(i).com = ACTIVE THEN
                com_active_v := TRUE;
              END IF;
            END LOOP;  -- i

            IF com_active_v = FALSE THEN
              write_rsp_err_valid_q <= TRUE;
            END IF;

          --
          -- STATE FSM ERROR
          --
          WHEN ST_FSM_ERROR =>
            dmm_e_q.write_ctrl_fsm_err <= '1';

        END CASE;

        --------------------------------------------------------------------
        -- Reset Logic
        --------------------------------------------------------------------
        --
        --
        --
        IF afu_reset = '1' THEN
          --
          -- initial values
          --
          com_wtag_next_q        <= "000001";
          com_wtag_p_q           <= '1';
          com_wtag_q             <= (OTHERS => '0');
          rsp_wtag_next_q        <= "000001";
          rsp_wtag_p_q           <= '1';
          rsp_wtag_q             <= (OTHERS => '0');
          write_ctrl_fsm_q       <= ST_IDLE;
          write_fsm_req_q        <= NONE;
          write_rsp_err_addr_p_q <= '1';
          write_rsp_err_addr_q   <= (OTHERS => '0');
          write_rsp_err_first_q  <= FALSE;
          write_rsp_err_type_q   <= ILLEGAL_RSP;
          write_rsp_err_valid_q  <= FALSE;
        END IF;
      END IF;
    END PROCESS write_ctrl_fsm;


  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- WRITE CONTROL REGISTER
  --
  -- Content: 32x(com   1    -- command valid bit
  --              rsp   4    -- response codes
  --              buf   2    -- buffer valid bit
  --              dma   2    -- psl dma control
  --              utt   3    -- utag type
  --              uta   58   -- utag address
  --
  -- Indication:
  --                               |    COM   |     RSP     |  BUF  | DMA       | UTT
  --  =====================================================================================
  --  1)tag and buffer are free    | INACTIVE | ILLEGAL_RSP | EMPTY | EMPTY     | UTC_NOT_USED
  --    ready to fill up           |          |             |       |           |
  --                               |          |             |       |           |
  --  2)reserve buffer space       | INACTIVE | ILLEGAL_RSP | EMPTY | EMPTY     | COMPLETE
  --                               |          |             |       |           |
  --  3)data in buffer, ready to   | INACTIVE | ILLEGAL_RSP | FULL  | EMPTY     | COMPLETE
  --    write                      |          |             |       |           |
  --                               |          |             |       |           |
  --  4)request a xlat for this CL | ACTIVE   | ILLEGAL_RSP | FULL  | EMPTY     | COMPLETE
  --                               |          |             |       |           |
  --  5)received xlat response     | INACTIVE | HA_RSP_CODE | FULL  | EMPTY     | COMPLETE
  --    from HA                    |          |             |       |           |
  --                               |          |             |       |           |
  --  6)response DONE and the ITAG | INACTIVE | ILLEGAL_RSP | FULL  | XLAT_DONE | COMPLETE
  --    is available, write data   |          |             |       |           |
  --                               |          |             |       |           |
  --  7)DMA accept the write Data  | INACTIVE | ILLEGAL_RSP | EMPTY | EMPTY     | UTC_NOT_USED
  --
  --
  -- Flow Control:
  --    steps                  | write_ctrl_q         |  H<->A Interface
  --  ==========================================================================
  --    1) wclen > 1 CL AND    | utt=COMPLETE         |
  --       utt  = UTC_NOT_USED |                      |
  --                           |                      |
  --    2) 128 bytes written   | buf=FULL             |
  --       into DMAW           |                      |
  --                           |                      |
  --    3) buf = FULL          | com=ACTIVE           |  WRITE XLAT COMMAND VALID
  --                           | rsp=ILLEGAL_RSP      |
  --                           |                      |
  --    4) response from PSL   | rsp=ha_r_q.response  |  RSP VALID
  --                           | com=INACTIVE         |
  --                           |                      |
  --    5) rsp = DONE          | rsp=ILLEGAL_RSP      |
  --                           | dma=XLAT_DONE        |
  --                           |                      |
  --    6) hd_s.valid = '1'    | dma=REQ_DONE         | PSL accept the request
  --                           |                      |
  --    7) buffer ready for    | buf=EMPTY            |
  --       reuse               |                      |
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    --
    write_ctrl_reg : PROCESS (ha_pclock)
      VARIABLE buf_wtag_v      : integer RANGE 0 TO 31;
      VARIABLE buf_full_v      : boolean;
      VARIABLE utc_wtag_v      : integer RANGE 0 TO 31;
      VARIABLE utc_wtag_next_v : integer RANGE 0 TO 31;
      VARIABLE dma_req_wtag_v  : integer RANGE 0 TO 31;
      VARIABLE ha_r_tag_v      : integer RANGE 0 TO 31;
      VARIABLE cl_calc_v       : std_logic_vector(5 DOWNTO 0);
    BEGIN
      IF (rising_edge(ha_pclock)) THEN
        --
        -- defaults
        --
        utc_wtag_q            <= utc_wtag_q;
        utc_wtag_next_q       <= utc_wtag_next_q;
        utc_wtag_p_q          <= utc_wtag_p_q;
        com_wtag_qq           <= to_integer(unsigned(com_wtag_q(4 DOWNTO 0)));
        dma_req_wtag_q        <= dma_req_wtag_q;
        rsp_wtag_qq           <= to_integer(unsigned(rsp_wtag_q(4 DOWNTO 0)));
         
        waddr_q               <= waddr_q;
        waddr_id_q            <= waddr_id_q;
        wr_id_valid_q         <= '0';
        write_ctrl_q          <= write_ctrl_q;
        wlen_q                <= wlen_q;
        wr_req_ack_q          <= FALSE;
        wr_ctx_q              <= wr_ctx_q;
         
        buf_wtag_v            := to_integer(unsigned(buf_wtag_q     (4 DOWNTO 0)));
        utc_wtag_v            := to_integer(unsigned(utc_wtag_q     (4 DOWNTO 0)));
        utc_wtag_next_v       := to_integer(unsigned(utc_wtag_next_q(4 DOWNTO 0)));
        dma_req_wtag_v        := to_integer(unsigned(dma_req_wtag_q (4 DOWNTO 0)));
        ha_r_tag_v            := to_integer(unsigned(ha_r_q.tag     (4 DOWNTO 0)));
         
        --
        -- UTT: CACHE LINE TYPE TAG IS VALID and
        -- UTS: CACHE LINE SIZE
        --
        -- Note: The alignment on the CAPI 2.0 DMA Data interface is
        --       first byte first.
        IF (write_ctrl_q(utc_wtag_v).utt  = UTC_NOT_USED) AND
           (wlen_q                       /= 0          ) THEN
         
          --
          -- update the utt in the write control register
          --
          IF waddr_q(8 DOWNTO 6) /= "000" THEN
            IF (or_reduce(wlen_q(8 DOWNTO 4))                              = '1'     ) OR 
               ((('0' & wlen_q(3 DOWNTO 0)) + ("00" & waddr_q(8 DOWNTO 6))) > "01000")  THEN
              wlen_q                      <= wlen_q - ("1000" - ('0' & waddr_q(8 DOWNTO 6)));
              write_ctrl_q(utc_wtag_v).uts <=  ("1000" - ('0' & waddr_q(8 DOWNTO 6)));
              write_ctrl_q(utc_wtag_v).utt <= UTC_FIRST;
            ELSE
              wlen_q                      <= (OTHERS => '0');
              write_ctrl_q(utc_wtag_v).uts <=  '0' & wlen_q(2 DOWNTO 0);
              write_ctrl_q(utc_wtag_v).utt <= UTC_LAST;
            END IF;
          ELSE
            IF wlen_q > 8 THEN
              write_ctrl_q(utc_wtag_v).uts <= "1000";
              write_ctrl_q(utc_wtag_v).utt <= UTC_COMPLETE;
              wlen_q <= wlen_q - 8;
            ELSIF wlen_q = 8 THEN
              write_ctrl_q(utc_wtag_v).uts <= "1000";
              write_ctrl_q(utc_wtag_v).utt <= UTC_LAST;
              wlen_q <= wlen_q - 8;
            ELSE
              write_ctrl_q(utc_wtag_v).uts <=  '0' & wlen_q(2 DOWNTO 0);
              write_ctrl_q(utc_wtag_v).utt <= UTC_LAST;
              wlen_q <= (OTHERS => '0');
            END IF;
          END IF;
         
          --
          -- CL Write Address
          write_ctrl_q(utc_wtag_v).uta   <= waddr_q(63 DOWNTO 6);
         
          --
          -- calculate the next write address
          waddr_q(63 DOWNTO 9) <= waddr_q(63 DOWNTO 9)  + VALUE_512;
          waddr_q( 8 DOWNTO 6) <= (OTHERS => '0');
         
          -- calculate the next utc wtag
          utc_wtag_q      <= utc_wtag_q      + 1;
          utc_wtag_next_q <= utc_wtag_next_q + 1;
          utc_wtag_p_q    <= AC_PPARITH(1, utc_wtag_q, utc_wtag_p_q,
                                           "000001"  , '0');
        END IF;
         
        --
        -- request
        IF (sd_c_q.wr_req = '1') AND
           (quiesce_q     = '0') AND
           (wlen_q        = 0  ) THEN
         
          --
          -- save the write address for later use
          waddr_q    <= sd_c_q.wr_addr(63 DOWNTO 6);
          waddr_id_q <= sd_c_q.wr_id;
          wr_ctx_q   <= sd_c_q.wr_ctx;
          wlen_q     <= ('0' & sd_c_q.wr_len) + 1;
         
         
           --
          -- send back a AXI write acknowledge
          wr_req_ack_q <= TRUE;
        END IF;
         
        --
        -- BUF: BUFFER TAG is valid
        --
        IF (buf_wwen_q = TRUE) THEN
          write_ctrl_q(buf_wtag_v).buf <=  write_ctrl_q(buf_wtag_v).buf + 1;
        END IF;
         
        --
        -- COM: WRITE COMMAND TAG IS VALID
        --
        IF com_wtag_valid_q = TRUE THEN
          write_ctrl_q(com_wtag_qq).com <= ACTIVE;
          write_ctrl_q(com_wtag_qq).rsp <= ILLEGAL_RSP;
        END IF;
         
        --
        -- RSP: VALID RESPONSE ON THE H->A INTERFACE
        --
        IF (ha_r_q.valid = '1') THEN
          --
          -- write tag is valid
          IF (ha_r_q.tag(7 DOWNTO 5) = "100") THEN
            write_ctrl_q(ha_r_tag_v).com  <= INACTIVE;
            write_ctrl_q(ha_r_tag_v).rsp  <= ha_r_q.response;
            write_ctrl_q(ha_r_tag_v).itag <= ha_r_q.ditag;
          END IF;
        END IF;
         
        --
        -- RSP: WRITE_CTRL_FSM_Q HAS READ THE RESPONSE
        --
        IF rsp_wtag_valid_q = TRUE THEN
          write_ctrl_q(rsp_wtag_qq).dma <= XLAT_DONE;
          write_ctrl_q(rsp_wtag_qq).rsp <= ILLEGAL_RSP;
        END IF;
         
        --
        -- BUF: DMA TAG is valid
        --
        IF (hd_s_q.utag_valid       = '1'    ) AND
           (hd_s_q.utag(9 DOWNTO 5) = "00100") THEN
          write_ctrl_q(to_integer(unsigned(hd_s_q.utag(4 DOWNTO 0)))).dma <= REQ_DONE;
        END IF;
         
        --
        --
        --
        IF  write_ctrl_q(dma_req_wtag_v).dma = REQ_DONE  THEN
          dma_req_wtag_q <= dma_req_wtag_q + 1;
         
          write_ctrl_q(dma_req_wtag_v).dma <= EMPTY;
          write_ctrl_q(dma_req_wtag_v).buf <= (OTHERS => '0');
          write_ctrl_q(dma_req_wtag_v).utt <= UTC_NOT_USED;
         
          --
          -- send back wr_id_valid if the last CL of a request was
          -- transfered
          IF write_ctrl_q(dma_req_wtag_v).utt = UTC_LAST THEN
            wr_id_valid_q <= '1';
          END IF;
         
        END IF;
        --
        -- DMA WRITE BUFFER OVERRUN CHECKER
        --
        buf_full_v  := TRUE;
         
        FOR i IN 0 TO 31 LOOP
          IF write_ctrl_q(i).buf /= write_ctrl_q(i).uts THEN
            buf_full_v := FALSE;
          END IF;
        END LOOP;  -- i
         
        IF ( buf_full_v = TRUE )AND
           ((or_reduce(sd_d_i.wr_strobe) = '1')) THEN
          assert false report "DMA: Write Buffer overrun" severity error;
        END IF;
         
        --------------------------------------------------------------------
        -- Reset Logic
        --------------------------------------------------------------------
        --
        --
        --
         IF afu_reset = '1' THEN
          --
          -- initial values
          --
          FOR i IN 0 TO 31 LOOP
            write_ctrl_q(i).utt <= UTC_NOT_USED;
            write_ctrl_q(i).rsp <= ILLEGAL_RSP;
            write_ctrl_q(i).com <= INACTIVE;
            write_ctrl_q(i).buf <= (OTHERS => '0');
            write_ctrl_q(i).uts <= (OTHERS => '0');
            write_ctrl_q(i).dma <= EMPTY;
         END LOOP;  -- i

          utc_wtag_q            <= (OTHERS => '0');
          utc_wtag_next_q       <= "000001";
          utc_wtag_p_q          <= '1';
          com_wtag_qq           <= 0;
          dma_req_wtag_q        <= (OTHERS => '0');
          rsp_wtag_qq           <= 0;

          wlen_q                <= (OTHERS => '0');
        END IF;
      END IF;
    END PROCESS write_ctrl_reg;


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- ******************************************************
-- ***** PSL DMA INTERFACE                          *****
-- ******************************************************
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- DMA FSM
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    --
    --
    --
    dma_fsm : PROCESS (ha_pclock)
      VARIABLE dma_rtag_v       : integer RANGE 0 TO 31;
      VARIABLE dma_rtag_next_v  : integer RANGE 0 TO 31;
      VARIABLE dma_wtag_v       : integer RANGE 0 TO 31;
      VARIABLE dma_wtag_next_v  : integer RANGE 0 TO 31;
    BEGIN
      IF (rising_edge(ha_pclock)) THEN
        --
        -- defaults
        --
        dma_rtag_q        <= dma_rtag_q;
        dma_rtag_v        := to_integer(unsigned(dma_rtag_q     (4 DOWNTO 0)));
        dma_rtag_next_v   := to_integer(unsigned(dma_rtag_next_q(4 DOWNTO 0)));

        dma_wtag_q        <= dma_wtag_q;
        dma_wtag_v        := to_integer(unsigned(dma_wtag_q     (4 DOWNTO 0)));
        dma_wtag_next_v   := to_integer(unsigned(dma_wtag_next_q(4 DOWNTO 0)));

        dh_d_q            <= ('0', (OTHERS => '0'), (OTHERS => '0'), (OTHERS => '0'), (OTHERS => '0'),
                              '0', (OTHERS => '0'), (OTHERS => '0'));

        buf_wrdreq_q <= FALSE;

        --
        -- F S M
        --
        CASE dma_fsm_q IS
          --
          -- STATE IDLE
          --
          WHEN ST_IDLE =>
            IF (read_ctrl_q(dma_rtag_v).dma  = XLAT_DONE ) AND
                (rsp_rtag_q                 /= dma_rtag_q) AND
               (dma_rreq_cnt_q               < 7         )THEN
              dma_fsm_q <= ST_DMA_READ_REQ;
            ELSIF  (write_ctrl_q(dma_wtag_v).dma  = XLAT_DONE ) AND
                   (rsp_wtag_q                   /= dma_wtag_q) AND
                   (dma_wreq_cnt_q                < 7         )THEN
              dma_fsm_q    <= ST_DMA_WRITE_REQ;
              buf_wrdreq_q <= TRUE;
            END IF;

          --------------------------------------------------------------------
          -- COMMAND STATES
          --------------------------------------------------------------------
          --
          -- STATE COMMAND: DMA READ REQUEST
          --
          WHEN ST_DMA_READ_REQ =>
            IF (read_ctrl_q(dma_rtag_next_v).dma  = XLAT_DONE      ) AND
                (rsp_rtag_q                      /= dma_rtag_next_q) AND
               (dma_rreq_cnt_q                   < 7               ) THEN
              dma_fsm_q <= ST_DMA_READ_REQ;
            ELSE
              dma_fsm_q <= ST_IDLE;
            END IF;

            --
            -- send out the DMA request
            --
            dma_rtag_q      <= dma_rtag_q      + 1;
            dma_rtag_next_q <= dma_rtag_next_q + 1;

            dh_d_q.valid    <= '1';
            dh_d_q.req_utag <= "00000" & dma_rtag_q(4 DOWNTO 0);
            dh_d_q.req_itag <= read_ctrl_q(dma_rtag_v).itag;
            dh_d_q.req_type <= "000";
            dh_d_q.size     <= read_ctrl_q(dma_rtag_v).uts & "000000";

          --
          -- STATE COMMAND: DMA WRITE REQUEST
          --
          WHEN ST_DMA_WRITE_REQ =>
            IF (write_ctrl_q(dma_wtag_next_v).dma  = XLAT_DONE ) AND
               (rsp_wtag_q                        /= dma_wtag_q) AND
               (dma_wreq_cnt_q                     < 7         ) THEN
              buf_wrdreq_q <= TRUE;
              dma_fsm_q    <= ST_DMA_WRITE_REQ;
            ELSE
              buf_wrdreq_q <= FALSE;

              IF (buf_wdata_vld = '1') AND
                 (buf_wdata_end = '1') THEN 
                dma_fsm_q <= ST_IDLE;
              END IF;
            END IF;

            --
            -- send out the DMA request
            --
            dh_d_q.valid    <= buf_wdata_vld;
            dh_d_q.req_utag <= "00100" & dma_wtag_q(4 DOWNTO 0);
            dh_d_q.req_itag <= write_ctrl_q(dma_wtag_v).itag;
            dh_d_q.req_type <= buf_wdata_type;
            dh_d_q.size     <= write_ctrl_q(dma_wtag_v).buf & "000000";

            IF (buf_wdata_vld = '1') AND
               (buf_wdata_end = '1') THEN 
              dma_wtag_q      <= dma_wtag_q      + 1;
              dma_wtag_next_q <= dma_wtag_next_q + 1;
            END IF;

          --
          -- STATE FSM ERROR
          --
          WHEN ST_FSM_ERROR =>

        END CASE;

        --------------------------------------------------------------------
        -- Reset Logic
        --------------------------------------------------------------------
        --
        --
        --
        IF afu_reset = '1' THEN
          dma_fsm_q       <= ST_IDLE;
          dma_rtag_q      <= (OTHERS => '0');
          dma_rtag_next_q <= "000001";
          dma_wtag_q      <= (OTHERS => '0');
          dma_wtag_next_q <= "000001";
        END IF;
      END IF;
    END PROCESS dma_fsm;


  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- MISC Logic
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    --
    --
    --
    psl_dma : PROCESS (ha_pclock)
    BEGIN
      IF (rising_edge(ha_pclock)) THEN
        --
        -- defaults
        --
        dma_rreq_cnt_q <= dma_rreq_cnt_q;
        dma_wreq_cnt_q <= dma_wreq_cnt_q;

        --
        -- DMA Read Request Counter
        --
        IF (hd_s_q.utag_valid       = '1') AND
           (hd_s_q.utag(9 DOWNTO 5) = "00000") THEN
          IF dma_fsm_q /= ST_DMA_READ_REQ THEN
            dma_rreq_cnt_q <= dma_rreq_cnt_q - 1;
          END IF;
        ELSE
          IF dma_fsm_q = ST_DMA_READ_REQ THEN
            dma_rreq_cnt_q <= dma_rreq_cnt_q + 1;
          END IF;
        END IF;

        --
        -- DMA Write Request Counter
        --
        IF (hd_s_q.utag_valid       = '1') AND
           (hd_s_q.utag(9 DOWNTO 5) = "00100") THEN
          IF NOT ((dma_fsm_q      = ST_DMA_WRITE_REQ) AND 
                  (buf_wdata_vld  = '1'             ) AND 
                  (buf_wdata_type = "001"           )) THEN
            dma_wreq_cnt_q <= dma_wreq_cnt_q - 1;
          END IF;
        ELSE
          IF (dma_fsm_q      = ST_DMA_WRITE_REQ) AND 
             (buf_wdata_vld  = '1'             ) AND 
             (buf_wdata_type = "001"           ) THEN
            dma_wreq_cnt_q <= dma_wreq_cnt_q + 1;
          END IF;
        END IF;

        --
        -- Reset Logic
        --
        IF afu_reset = '1' THEN
          dma_rreq_cnt_q <= 0;
          dma_wreq_cnt_q <= 0;
        END IF;
      END IF;
    END PROCESS psl_dma;



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- ******************************************************
-- ***** DMA PSL OUTPUT LOGIC                       *****
-- ******************************************************
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- AH Command Interface
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    --
    ah_c_ctl : PROCESS (ha_pclock)
      VARIABLE ah_c_valid_v : std_logic;
      VARIABLE ah_c_counter_v  : integer RANGE 0 TO 255;

    BEGIN
      IF (rising_edge(ha_pclock)) THEN
        --
        -- defaults
        --
        ah_c_q                <= ( '0',                    -- valid
                                  (OTHERS => '0'),         -- tag
                                   '1',                    -- tagpar
                                   INVALID,                -- com
                                   '1',                    -- compar
                                  (OTHERS => '0'),         -- abt
                                  (OTHERS => '0'),         -- ea
                                   '1',                    -- eapar
                                  (OTHERS => '0'),         -- ch
                                  (OTHERS => '0'));        -- size
        ah_c_fsm_q            <= ah_c_fsm_q;
        ah_c_max_q            <= ha_c_q.room - x"04";
        ah_c_max_reached_q    <= ah_c_max_reached_q;
        ah_c_rgate_q          <= ah_c_rgate_q;
        ah_c_rsp_err_addr_p_q <= ah_c_rsp_err_addr_p_q;
        ah_c_rsp_err_addr_q   <= ah_c_rsp_err_addr_q;
        ah_c_rsp_err_first_q  <= ah_c_rsp_err_first_q;
        ah_c_rsp_err_type_q   <= ah_c_rsp_err_type_q;
        ah_c_rsp_err_valid_q  <= ah_c_rsp_err_valid_q;
        ah_c_wgate_q          <= ah_c_wgate_q;
        dmm_e_q.ah_c_fsm_err  <= '0';
        intreq_active_q       <= intreq_active_q;
        int_src_q             <= int_src_q;
        int_ctx_q             <= int_ctx_q;
        int_req_ack_q         <= '0';
        mmd_a_q               <= ('0','0','0'); -- mmd_a_i;
        restart_active_q      <= restart_active_q;

        -- intreq is active
        IF (sd_c_i.int_req = '1') THEN
          intreq_active_q <= TRUE;
          int_src_q       <= sd_c_i.int_src;
          int_ctx_q       <= sd_c_i.int_ctx;
        END IF;

        ------------------------------------------------------------------------
        -- AH Command Count Logic
        ------------------------------------------------------------------------
        IF (ah_c_q.valid = '1') AND
           (ha_r_q.valid = '0') THEN
          ah_c_counter_v := ah_c_counter_q + 1;
        ELSIF (ah_c_q.valid = '0') AND
              (ha_r_q.valid = '1') THEN
          ah_c_counter_v := ah_c_counter_q - 1;
        ELSE
          ah_c_counter_v := ah_c_counter_q;
        END IF;

        ah_c_counter_q <= ah_c_counter_v;

        --
        -- Note: It takes 4 cycles to stop the full command
        --       pipe
        --
        IF ah_c_counter_v  < to_integer(unsigned(ah_c_max_q))  THEN
          ah_c_max_reached_q <= FALSE;
        ELSE
          ah_c_max_reached_q <= TRUE;
        END IF;

        ------------------------------------------------------------------------
        -- F S M
        ------------------------------------------------------------------------
        CASE ah_c_fsm_q IS
          --
          -- STATE IDLE
          --
          WHEN ST_IDLE =>
            ah_c_rgate_q <= CLOSED;
            ah_c_wgate_q <= CLOSED;

            --
            -- max commands reached, stay in IDLE
            IF (ah_c_max_reached_q = TRUE) THEN
              ah_c_fsm_q   <= ST_IDLE;
              ah_c_rgate_q <= CLOSED;
              ah_c_wgate_q <= CLOSED;

            --
            -- RESTART
            ELSIF (read_fsm_req_q  = RESTART) OR
                  (write_fsm_req_q = RESTART) THEN
              ah_c_fsm_q       <= ST_COM_RESTART;
              restart_active_q <= TRUE;

            --
            -- open read gate
            ELSIF (read_fsm_req_q       = COMMAND) AND
                  (mmd_a_q.thr_read_fsm = '0'    ) THEN
              ah_c_fsm_q   <= ST_READ_FSM_ACTIVE;
              ah_c_rgate_q <= OPENED;

            --
            -- open write gate
            ELSIF (write_fsm_req_q       = COMMAND) AND
                  (mmd_a_q.thr_write_fsm = '0'    ) THEN
              ah_c_fsm_q   <= ST_WRITE_FSM_ACTIVE;
              ah_c_wgate_q <= OPENED;

            --
            -- interrupt
            ELSIF (intreq_active_q  = TRUE   ) AND
                  (write_ctrl_fsm_q = ST_IDLE) THEN
              ah_c_fsm_q <= ST_COM_INT_REQ;
            END IF;

          --
          -- STATE READ FSM ACTIVE
          --
          WHEN ST_READ_FSM_ACTIVE =>
            ah_c_q.valid                       <= ah_rc_q.valid;
            ah_c_q.tag                         <= ah_rc_q.tag;
            ah_c_q.tagpar                      <= ah_rc_q.tagpar XOR mmd_i_q.inject_ah_c_tagpar_error;
            ah_c_q.com                         <= ah_rc_q.com;
            ah_c_q.compar                      <= ah_rc_q.compar XOR mmd_i_q.inject_ah_c_compar_error;
            ah_c_q.abt                         <= ah_rc_q.abt;
            ah_c_q.ea                          <= ah_rc_q.ea & "000000";
            ah_c_q.eapar                       <= ah_rc_q.eapar XOR mmd_i_q.inject_ah_c_eapar_error;
            ah_c_q.ch(CONTEXT_BITS-1 DOWNTO 0) <= rd_ctx_q;

            --
            --  max commands reached, closing the gate, but allow
            --  to transfer the command that is on the fly
            --
            IF (ah_c_max_reached_q  = TRUE) OR
               (mmd_a_q.thr_cmd_fsm = '1' ) THEN
              ah_c_rgate_q <= CLOSED;
            ELSE
              ah_c_rgate_q <= OPENED;
            END IF;

            --
            -- read_fsm no longer needs the command bus
            --
            IF read_fsm_req_q /= COMMAND THEN
              ah_c_fsm_q   <= ST_IDLE;
              ah_c_rgate_q <= CLOSED;
            END IF;

          --
          -- STATE WRITE FSM ACTIVE
          --
          WHEN ST_WRITE_FSM_ACTIVE =>
            ah_c_q.valid                       <= ah_wc_q.valid;
            ah_c_q.tag                         <= ah_wc_q.tag;
            ah_c_q.tagpar                      <= ah_wc_q.tagpar XOR mmd_i_q.inject_ah_c_tagpar_error;
            ah_c_q.com                         <= ah_wc_q.com;
            ah_c_q.compar                      <= ah_wc_q.compar XOR mmd_i_q.inject_ah_c_compar_error;
            ah_c_q.abt                         <= ah_wc_q.abt;
            ah_c_q.ea                          <= ah_wc_q.ea & "000000";
            ah_c_q.eapar                       <= ah_wc_q.eapar XOR mmd_i_q.inject_ah_c_eapar_error;
            ah_c_q.ch(CONTEXT_BITS-1 DOWNTO 0) <= wr_ctx_q;

            --
            --  max commands reached, closing the gate, but allow
            --  to transfer the command that is on the fly
            --
            IF (ah_c_max_reached_q  = TRUE) OR
               (mmd_a_q.thr_cmd_fsm = '1' ) THEN
              ah_c_wgate_q <= CLOSED;
            ELSE
              ah_c_wgate_q <= OPENED;
            END IF;

            --
            -- write_fsm no longer needs the command bus
            --
            IF write_fsm_req_q /= COMMAND THEN
              ah_c_fsm_q   <= ST_IDLE;
              ah_c_wgate_q <= CLOSED;
            END IF;

          --
          -- STATE COMMAND: RESTART
          --
          WHEN ST_COM_RESTART =>
            ah_c_fsm_q       <= ST_WAIT_4_RSP;

            ah_c_q.valid    <= '1';
            ah_c_q.tag      <= x"F0";
            ah_c_q.tagpar   <= '1' XOR mmd_i_q.inject_ah_c_tagpar_error;
            ah_c_q.com      <= RESTART;
            ah_c_q.compar   <= parity_gen_odd(ENCODE_CMD_CODES(RESTART)) XOR mmd_i_q.inject_ah_c_compar_error;

          --
          -- STATE COMMAND: INTERRUPT REQUEST
          --
          WHEN ST_COM_INT_REQ =>
            ah_c_fsm_q                         <= ST_WAIT_4_RSP;
            ah_c_q.valid                       <= '1';
            ah_c_q.tag                         <= x"F1";
            ah_c_q.tagpar                      <= '0' XOR mmd_i_q.inject_ah_c_tagpar_error;
            ah_c_q.com                         <= INTREQ;
            ah_c_q.compar                      <= parity_gen_odd(ENCODE_CMD_CODES(INTREQ)) XOR mmd_i_q.inject_ah_c_compar_error;
            ah_c_q.ea                          <= x"0000_0000_0000_000" & '0' & int_src_q;
            ah_c_q.eapar                       <= parity_gen_odd(int_src_q) XOR mmd_i_q.inject_ah_c_eapar_error;
            ah_c_q.ch(CONTEXT_BITS-1 DOWNTO 0) <= int_ctx_q;

          --
          -- STATE WAIT: FOR RESPONSE
          --
          WHEN ST_WAIT_4_RSP =>
            IF (ha_r_q.valid           = '1' ) AND
               (ha_r_q.tag(7 DOWNTO 4) = x"F") THEN
              IF (ha_r_q.response = DONE) THEN
                ah_c_fsm_q       <= ST_IDLE;

                IF (ha_r_q.tag(3 DOWNTO 0) = x"0") THEN
                  -- deactivate RESTART
                  restart_active_q <= FALSE;

                ELSIF (ha_r_q.tag(3 DOWNTO 0) = x"1") THEN
                  -- deactivate INTREQ
                  intreq_active_q <= FALSE;
                  int_req_ack_q   <= '1';
                END IF;
              ELSE
                ah_c_fsm_q <= ST_RSP_ERROR;
                restart_active_q <= FALSE;
                intreq_active_q  <= FALSE;
                --
                -- collect all information
                ah_c_rsp_err_type_q   <= ha_r_q.response;
                ah_c_rsp_err_addr_q   <= ha_r_q.tag(7 DOWNTO 0) & x"00000000000000";
                ah_c_rsp_err_addr_p_q <= ha_r_q.tagpar;

              END IF;
            END IF;

          --
          -- STATE RSP ERROR
          --
          WHEN ST_RSP_ERROR =>
            --
            -- how is first check
            IF (read_ctrl_fsm_q  /= ST_RSP_ERROR) OR
               (write_ctrl_fsm_q /= ST_RSP_ERROR) THEN
              ah_c_rsp_err_first_q <= TRUE;
            END IF;

            ah_c_rsp_err_valid_q <= TRUE;

          --
          -- STATE FSM ERROR
          --
          WHEN ST_FSM_ERROR =>
            dmm_e_q.ah_c_fsm_err <= '1';

        END CASE;

        --------------------------------------------------------------------
        -- Reset Logic
        --------------------------------------------------------------------
        --
        --
        --

        IF afu_reset = '1' THEN
          --
          -- initial values
          --
          ah_c_fsm_q            <= ST_IDLE;
          ah_c_max_reached_q    <= FALSE;
          ah_c_rgate_q          <= CLOSED;
          ah_c_rsp_err_addr_p_q <= '1';
          ah_c_rsp_err_addr_q   <= (OTHERS => '0');
          ah_c_rsp_err_first_q  <= FALSE;
          ah_c_rsp_err_type_q   <= ILLEGAL_RSP;
          ah_c_rsp_err_valid_q  <= FALSE;
          ah_c_wgate_q          <= CLOSED;
          intreq_active_q       <= FALSE;
          int_src_q             <= (OTHERS => '0');
          int_ctx_q             <= (OTHERS => '0');
          int_req_ack_q         <= '0';
          restart_active_q      <= FALSE;
        END IF;
      END IF;
    END PROCESS ah_c_ctl;



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- ******************************************************
-- ***** DMA SUB LOGIC                              *****
-- ******************************************************
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- DMA BUFFER
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    dma_buf: ENTITY work.dma_buffer
    PORT MAP (
      --
      -- pervasive
      ha_pclock                => ha_pclock,
      afu_reset                => afu_reset,
      --
      -- PSL IOs
      hd_c_i                   => hd_c_i,
      --
      -- DMA WRITE IOs
      write_ctrl_i             => write_ctrl_q,
      sd_d_i                   => sd_d_i,
      buf_wrdreq_i             => buf_wrdreq_q,
      buf_wtag_o               => buf_wtag_q,
      buf_wwen_o               => buf_wwen_q,
      buf_wdata_o              => buf_wdata,
      buf_wdata_vld_o          => buf_wdata_vld,
      buf_wdata_end_o          => buf_wdata_end,
      buf_wdata_type_o         => buf_wdata_type,
      buf_wram_wready_o        => buf_wram_wready,
      --
      -- DMA READ IOs
      read_ctrl_i              => read_ctrl_q,
      buf_rrdreq_i             => buf_rrdreq,
      buf_rdata_o              => buf_rdata,
      buf_rdata_p_o            => buf_rdata_p,
      buf_rdata_vld_o          => buf_rdata_vld,
      buf_rdata_end_o          => buf_rdata_end,
      buf_rtag_o               => buf_rtag_q,
      buf_rtag_p_o             => buf_rtag_p_q,
      buf_rtag_valid_o         => buf_rtag_valid_q,
      --
      -- Error Inject
      inject_dma_read_error_i  => mmd_i_q.inject_dma_read_error,
      inject_dma_write_error_i => mmd_i_q.inject_dma_write_error,
      inject_ah_b_rpar_error_i => mmd_i_q.inject_ah_b_rpar_error
    );

    dmm_e_q.write_data_p_err <= '0';
    buf_rrdreq               <= NOT rfifo_prog_full;

  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- DMA READ OUTPUT FIFO
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    -- FIFO: fifo_513x512
    ----------------------------------------------------------------------------
    --
    rfifo_wdata <= buf_rdata_end & buf_rdata;

    dma_read_fifo : fifo_513x512
    PORT MAP (
      clk          => ha_pclock,
      srst         => afu_reset,
      din          => rfifo_wdata,
      wr_en        => buf_rdata_vld,
      rd_en        => sd_d_i.rd_data_ack,
      dout         => rfifo_rdata,
      full         => rfifo_full,
      empty        => rfifo_empty,
      prog_full    => rfifo_prog_full,
      wr_rst_busy  => rfifo_wr_rst_busy,
      rd_rst_busy  => rfifo_rd_rst_busy
    );

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
---- ******************************************************
---- ***** RAS                                        *****
---- ******************************************************
----
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
  --
  -- FIR ASSERTS
  --
  assert dmm_e_q.ah_c_fsm_err       = '0' report "FIR: DMA ah_c fsm error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.read_ctrl_fsm_err  = '0' report "FIR: DMA read control fsm error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.read_ctrl_q_err    = '0' report "FIR: DMA read control register error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.write_ctrl_fsm_err = '0' report "FIR: DMA write control fsm error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.write_ctrl_q_err   = '0' report "FIR: DMA write control register error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.ha_r_tag_err       = '0' report "FIR: HA_R tag parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.ha_r_code_err      = '0' report "FIR: HA_R code error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.aln_read_fsm_err   = '0' report "FIR: DMA aligner read fsm error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.aln_write_fsm_err  = '0' report "FIR: DMA aligner write fsm error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.sd_p_err           = '0' report "FIR: AXI SLAVE parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.com_rtag_err       = '0' report "FIR: Read Command Pointer parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.clt_rtag_err       = '0' report "FIR: Read Cache Line Type Pointer parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.rsp_rtag_err       = '0' report "FIR: Read Response Pointer parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.buf_rtag_err       = '0' report "FIR: Read Buffer Pointer parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.raddr_err          = '0' report "FIR: Read Address parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.com_wtag_err       = '0' report "FIR: Write Command Pointer parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.clt_wtag_err       = '0' report "FIR: Write Cache Line Type Pointer parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.rsp_wtag_err       = '0' report "FIR: Write Response Pointer parity error" severity FIR_MSG_LEVEL;
  assert dmm_e_q.waddr_err          = '0' report "FIR: Write Address parity error" severity FIR_MSG_LEVEL;

  --
  -- ERROR OUTPUT
--  dmm_e_o <= dmm_e_q;

  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  -- PSL INPUT Checker
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
    --------------------------------------------------------------------------
    -- Response Bus Checking
    --------------------------------------------------------------------------
    ha_r_check : PROCESS (ha_pclock)
    BEGIN
      IF (rising_edge(ha_pclock)) THEN

        IF afu_reset = '1' THEN
          dmm_e_q.ha_r_tag_err <= '0';
          dmm_e_q.ha_r_code_err <= '0';

        ELSE
          --
          -- defaults
          --
          dmm_e_q.ha_r_tag_err <= '0';
          dmm_e_q.ha_r_code_err <= '0';

          IF ha_r_q.valid  = '1' THEN
            --
            -- response tag parity checking
            IF parity_gen_odd(ha_r_q.tag) /= ha_r_q.tagpar THEN
              dmm_e_q.ha_r_tag_err  <= '1';
            END IF;
            --
            -- response code checking
            IF ha_r_q.response = ILLEGAL_RSP THEN
              dmm_e_q.ha_r_code_err <= '1';
            END IF;
          END IF;

        END IF;
      END IF;
    END PROCESS ha_r_check;


  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  -- AXI SLAVE INPUT Checker
  --
  -- Placeolder
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
    s_p_check : PROCESS (ha_pclock)
    BEGIN
      IF (rising_edge(ha_pclock)) THEN

        IF afu_reset = '1' THEN
          dmm_e_q.sd_p_err <= '0';

        ELSE
          dmm_e_q.sd_p_err <= '0';

        END IF;
      END IF;
    END PROCESS s_p_check;


  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  -- DMA INTERNAL Checker
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
    --------------------------------------------------------------------------
    -- READ Logic Checking
    --------------------------------------------------------------------------
    read_ctrl_check : PROCESS (ha_pclock)
    BEGIN
      IF (rising_edge(ha_pclock)) THEN

        IF afu_reset = '1' THEN
          dmm_e_q.com_rtag_err    <= '0';
          dmm_e_q.clt_rtag_err    <= '0';
          dmm_e_q.rsp_rtag_err    <= '0';
          dmm_e_q.buf_rtag_err    <= '0';
          dmm_e_q.raddr_err       <= '0';
          dmm_e_q.read_ctrl_q_err <= '0';
          read_ctrl_q_err_q       <= (OTHERS => '0');

        ELSE
          --
          -- defaults
          --
          dmm_e_q.com_rtag_err    <= '0';
          dmm_e_q.clt_rtag_err    <= '0';
          dmm_e_q.rsp_rtag_err    <= '0';
          dmm_e_q.buf_rtag_err    <= '0';
          dmm_e_q.raddr_err       <= '0';
          dmm_e_q.read_ctrl_q_err <= '0';

          --
          -- com_rtag parity failure
          IF parity_gen_odd(com_rtag_q) /= com_rtag_p_q THEN
            dmm_e_q.com_rtag_err <= '1';
          END IF;

          IF parity_gen_odd(com_rtag_next_q - "00001") /= com_rtag_p_q THEN
            dmm_e_q.com_rtag_err <= '1';
          END IF;

          --
          -- utc_rtag parity failure
          IF parity_gen_odd(utc_rtag_q) /= utc_rtag_p_q THEN
            dmm_e_q.clt_rtag_err <= '1';
          END IF;

          IF parity_gen_odd(utc_rtag_next_q - "00001") /= utc_rtag_p_q THEN
            dmm_e_q.clt_rtag_err <= '1';
          END IF;

          --
          -- rsp_rtag parity failure
          IF parity_gen_odd(rsp_rtag_q) /= rsp_rtag_p_q THEN
            dmm_e_q.rsp_rtag_err <= '1';
          END IF;

          IF parity_gen_odd(rsp_rtag_next_q - "00001") /= rsp_rtag_p_q THEN
            dmm_e_q.rsp_rtag_err <= '1';
          END IF;

          --
          -- buf_rtag parity failure
          IF parity_gen_odd(buf_rtag_q) /= buf_rtag_p_q THEN
            dmm_e_q.buf_rtag_err <= '1';
          END IF;
          --
          -- raddr_q parity failure
          --IF parity_gen_odd(raddr_q) /= raddr_p_q THEN
          --  dmm_e_q.raddr_err <= '1';
          --END IF;
          --
          -- read_ctrl register checking
          --FOR i IN 0 TO 31 LOOP
          --  IF ((read_ctrl_q(i).com = INACTIVE) AND (read_ctrl_q(i).rsp  = ILLEGAL_RSP) AND (read_ctrl_q(i).buf = EMPTY) AND (read_ctrl_q(i).clt  = CL_NOT_USED)) OR
          --     ((read_ctrl_q(i).com = INACTIVE) AND (read_ctrl_q(i).rsp  = ILLEGAL_RSP) AND (read_ctrl_q(i).buf = EMPTY) AND (read_ctrl_q(i).clt /= CL_NOT_USED)) OR
          --     ((read_ctrl_q(i).com =   ACTIVE) AND (read_ctrl_q(i).rsp  = ILLEGAL_RSP) AND (read_ctrl_q(i).buf = EMPTY) AND (read_ctrl_q(i).clt /= CL_NOT_USED)) OR
          --     ((read_ctrl_q(i).com = INACTIVE) AND (read_ctrl_q(i).rsp /= ILLEGAL_RSP) AND (read_ctrl_q(i).buf = EMPTY) AND (read_ctrl_q(i).clt /= CL_NOT_USED)) OR
          --     ((read_ctrl_q(i).com = INACTIVE) AND (read_ctrl_q(i).rsp  = ILLEGAL_RSP) AND (read_ctrl_q(i).buf = FULL ) AND (read_ctrl_q(i).clt /= CL_NOT_USED)) THEN
          --    read_ctrl_q_err_q(i) <= '0';
          --  ELSE
          --    read_ctrl_q_err_q(i) <= '1';
          --  END IF;
          --END LOOP;  -- i
          dmm_e_q.read_ctrl_q_err <= or_reduce(read_ctrl_q_err_q);

        END IF;

      END IF;
    END PROCESS read_ctrl_check;

    --------------------------------------------------------------------------
    -- WRITE Logic Checking
    --------------------------------------------------------------------------
    write_ctrl_check : PROCESS (ha_pclock)
    BEGIN
      IF (rising_edge(ha_pclock)) THEN

         IF afu_reset = '1' THEN
          dmm_e_q.com_wtag_err <= '0';
          dmm_e_q.clt_wtag_err <= '0';
          dmm_e_q.rsp_wtag_err <= '0';
          dmm_e_q.waddr_err        <= '0';
          dmm_e_q.write_ctrl_q_err <= '0';
          write_ctrl_q_err_q       <= (OTHERS => '0');

        ELSE
          --
          -- defaults
          --
          dmm_e_q.com_wtag_err <= '0';
          dmm_e_q.clt_wtag_err <= '0';
          dmm_e_q.rsp_wtag_err <= '0';
          dmm_e_q.waddr_err        <= '0';
          dmm_e_q.write_ctrl_q_err <= '0';

          --
          -- com_wtag parity failure
          IF parity_gen_odd(com_wtag_q) /= com_wtag_p_q THEN
            dmm_e_q.com_wtag_err <= '1';
          END IF;

          IF parity_gen_odd(com_wtag_next_q - "00001") /= com_wtag_p_q THEN
            dmm_e_q.com_wtag_err <= '1';
          END IF;

          --
          -- utc_wtag parity failure
          IF parity_gen_odd(utc_wtag_q) /= utc_wtag_p_q THEN
            dmm_e_q.clt_wtag_err <= '1';
          END IF;

          IF parity_gen_odd(utc_wtag_next_q - "00001") /= utc_wtag_p_q THEN
            dmm_e_q.clt_wtag_err <= '1';
          END IF;

          --
          -- rsp_wtag parity failure
          IF parity_gen_odd(rsp_wtag_q) /= rsp_wtag_p_q THEN
            dmm_e_q.rsp_wtag_err <= '1';
          END IF;

          IF parity_gen_odd(rsp_wtag_next_q - "00001") /= rsp_wtag_p_q THEN
            dmm_e_q.rsp_wtag_err <= '1';
          END IF;

--          --
--          -- buf_wtag parity failure
--          IF parity_gen_odd(buf_wtag_q) /= buf_wtag_p_q THEN
--            dmm_e_q.buf_wtag_err <= '1';
--          END IF;

          --
          -- write_ctrl register checking
--          FOR i IN 0 TO 31 LOOP
--            IF ((write_ctrl_q(i).com = INACTIVE) AND (write_ctrl_q(i).rsp  = ILLEGAL_RSP) AND (write_ctrl_q(i).buf = EMPTY) AND (write_ctrl_q(i).clt  = CL_NOT_USED)) OR
--               ((write_ctrl_q(i).com = INACTIVE) AND (write_ctrl_q(i).rsp  = ILLEGAL_RSP) AND (write_ctrl_q(i).buf = EMPTY) AND (write_ctrl_q(i).clt /= CL_NOT_USED)) OR
--               ((write_ctrl_q(i).com = INACTIVE) AND (write_ctrl_q(i).rsp  = ILLEGAL_RSP) AND (write_ctrl_q(i).buf = FULL ) AND (write_ctrl_q(i).clt  = CL_NOT_USED)) OR  -- see comments IN  ST_WAIT_4_RSP_OR_BUF
--               ((write_ctrl_q(i).com = INACTIVE) AND (write_ctrl_q(i).rsp  = ILLEGAL_RSP) AND (write_ctrl_q(i).buf = FULL ) AND (write_ctrl_q(i).clt /= CL_NOT_USED)) OR
--               ((write_ctrl_q(i).com =   ACTIVE) AND (write_ctrl_q(i).rsp  = ILLEGAL_RSP) AND (write_ctrl_q(i).buf = FULL ) AND (write_ctrl_q(i).clt /= CL_NOT_USED)) OR
--               ((write_ctrl_q(i).com = INACTIVE) AND (write_ctrl_q(i).rsp /= ILLEGAL_RSP) AND (write_ctrl_q(i).buf = FULL ) AND (write_ctrl_q(i).clt /= CL_NOT_USED)) THEN
--              write_ctrl_q_err_q(i) <= '0';
--            ELSE
--              write_ctrl_q_err_q(i) <= '1';
--            END IF;
--          END LOOP;  -- i
          dmm_e_q.write_ctrl_q_err <= or_reduce(write_ctrl_q_err_q);

        END IF;
      END IF;
    END PROCESS write_ctrl_check;


  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  -- QUIESCE LOGIC
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
    --
    --
    --
    quiesce : PROCESS (ha_pclock)
    BEGIN
      IF (rising_edge(ha_pclock)) THEN
        action_reset_req_q        <= '0';
        sent_action_reset_req_q   <= sent_action_reset_req_q AND NOT cd_c_i.quiesce_release;
        action_reset_context_id_q <= action_reset_context_id_q;

        IF cd_c_i.quiesce_request = '1' THEN
          action_reset_context_id_q <= cd_c_i.quiesce_context_id;
        ELSIF mmd_c_i.quiesce_request = '1' THEN
          action_reset_context_id_q <= mmd_c_i.quiesce_context_id;
        END IF;
        
        quiesce_q <= (quiesce_q AND NOT cd_c_i.quiesce_release) OR
                      cd_c_i.quiesce_request                    OR
                      mmd_c_i.quiesce_request;

        IF (quiesce_q               = '1'                                                              ) AND
           (sent_action_reset_req_q = '0'                                                              ) AND
           (((read_ctrl_fsm_q  = ST_IDLE) AND (rfifo_empty = '1')) OR (read_ctrl_fsm_q  = ST_RSP_ERROR)) AND
           ( (write_ctrl_fsm_q = ST_IDLE)                          OR (write_ctrl_fsm_q = ST_RSP_ERROR)) THEN
          action_reset_req_q      <= '1';
          sent_action_reset_req_q <= '1';
        END IF;

        IF afu_reset = '1' THEN
          quiesce_q                 <= '0';
          sent_action_reset_req_q   <= '0';
          action_reset_context_id_q <= (OTHERS => '0');
        END IF;
      END IF;
    END PROCESS quiesce;


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- ******************************************************
-- ***** MISC                                       *****
-- ******************************************************
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  -- Output Connection
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    --
    -- PSL AH_C CONNECTION
    --
    ah_c_o <= ah_c_q;

    --
    -- PSL AH_C CONNECTION
    --
    dh_d_o.valid     <= dh_d_q.valid;
    dh_d_o.req_utag  <= dh_d_q.req_utag;
    dh_d_o.req_itag  <= dh_d_q.req_itag;
    dh_d_o.req_type  <= dh_d_q.req_type;
    dh_d_o.atomic_op <= (OTHERS => '0');
    dh_d_o.atomic_le <=  '0';
    dh_d_o.size      <= dh_d_q.size;
    dh_d_o.data      <= buf_wdata;

    --
    -- AXI SLAVE CONNECTION
    --
    ds_d_o.rd_data_strobe  <= NOT rfifo_empty;
    ds_d_o.rd_last         <= rfifo_rdata(512) AND NOT rfifo_empty;
    ds_d_o.rd_data         <= rfifo_rdata(511 DOWNTO 0);
    ds_d_o.rd_id           <= raddr_id_q;       -- Multi Action support: should be part of read_ctrl_q;
    ds_d_o.wr_data_ready   <= buf_wram_wready;

    ds_c_o.wr_req_ack  <= '1' WHEN wr_req_ack_q = TRUE ELSE '0';
    ds_c_o.rd_req_ack  <= '1' WHEN rd_req_ack_q = TRUE ELSE '0';
    ds_c_o.wr_id_valid <= wr_id_valid_q;
    ds_c_o.wr_id       <= waddr_id_q;             -- Multi Action support: should be part of write_ctrl_q
    ds_c_o.int_req_ack <= int_req_ack_q;

    --
    -- MMIO CONNECTION
    dmm_c_o.action_reset_req        <= action_reset_req_q;
    dmm_c_o.action_reset_context_id <= action_reset_context_id_q;


  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  --  Register
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
    --
    registers : PROCESS (ha_pclock)
    BEGIN
      IF (rising_edge(ha_pclock)) THEN
        --
        -- defaults
        --
        ha_c_q        <= ha_c_i;
        ha_r_q        <= ha_r_i;
        hd_c_q        <= hd_c_i;
        hd_s_q        <= hd_s_i;

        mmd_i_q       <= (OTHERS => '0'); --mmd_i_i;
        sd_c_q        <= sd_c_i;
        sd_c_q.rd_req <= '0';
        sd_c_q.wr_req <= '0';

        --
        --
        IF rd_req_ack_q = FALSE THEN
          sd_c_q.rd_req <= sd_c_i.rd_req;
        END IF;

        IF wr_req_ack_q = FALSE THEN
          sd_c_q.wr_req <= sd_c_i.wr_req;
        END IF;
      END IF;
    END PROCESS registers;
END ARCHITECTURE;
